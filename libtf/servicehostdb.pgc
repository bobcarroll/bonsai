/**
 * Bonsai - open source group collaboration and application lifecycle management
 * Copyright (c) 2011 Bob Carroll
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/**
 * @brief   Team Foundation service host database functions
 *
 * @author  Bob Carroll (bob.carroll@alum.rit.edu)
 */

#include <string.h>
#include <stdlib.h>

#include <gcs/log.h>

#include <tf/servicehost.h>

/**
 * Retrieves service hosts from the database. Calling functions should
 * call tf_free_host_array() to free "result".
 *
 * If parent is NULL then only TEAM FOUDATAION hosts will be returned.
 * Otherwise, hosts with the given parent will be returned.
 *
 * @param ctx       current database context
 * @param parent    optional parent ID to filter on
 * @param result    pointer to an output buffer for the results
 *
 * @return TF_ERROR_SUCCESS or an error code
 */
tf_error tf_fetch_hosts(pgctx *ctx, const char *parent, tf_host ***result)
{
    if (!ctx || !result || *result)
        return TF_ERROR_BAD_PARAMETER;

    gcslog_debug("looking up service hosts");

    EXEC SQL BEGIN DECLARE SECTION;
    const char *conn = ctx->conn;
    char countstmt[20480];
    char selstmt[20480];
    int count = 0;
    EXEC SQL END DECLARE SECTION;

    char where[1024];

    if (parent)
        snprintf(where, 1024, "WHERE parent_host_id = '%s'", parent);
    else
        sprintf(where, "WHERE parent_host_id IS NULL");

    sprintf(countstmt, 
        "SELECT COUNT(*) \
        FROM service_hosts \
        %s",
        where);
    gcslog_trace("fetch service hosts SQL: %s", countstmt);

    EXEC SQL WHENEVER SQLERROR GOTO error;
    EXEC SQL AT :conn PREPARE sqlstmt FROM :countstmt;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL AT :conn EXECUTE sqlstmt INTO :count;

    gcslog_debug("found %d service host(s)", count);
    *result = (tf_host **)calloc(count + 1, sizeof(tf_host *));

    if (count == 0)
        return TF_ERROR_SUCCESS;

    sprintf(selstmt, 
        "SELECT host_id, parent_host_id, \"name\", description, \
                virtual_directory, resource_directory, \
                connection_string, status, status_reason, \
                supported_features, fk_resource_identifier \
        FROM service_hosts \
        %s",
        where);

    EXEC SQL WHENEVER SQLERROR GOTO error_cur;
    EXEC SQL AT :conn PREPARE sqlstmt FROM :selstmt;

    EXEC SQL AT :conn DECLARE fetch_hosts CURSOR FOR sqlstmt;
    EXEC SQL AT :conn OPEN fetch_hosts;
    EXEC SQL WHENEVER SQLERROR GOTO error_cur;

    int i;
    for (i = 0; ; i++) {
        EXEC SQL WHENEVER NOT FOUND DO BREAK;

        EXEC SQL BEGIN DECLARE SECTION;
        char id[TF_SERVICE_HOST_ID_MAXLEN];
        char parent[TF_SERVICE_HOST_ID_MAXLEN];
        int parent_ind;
        char name[TF_SERVICE_HOST_NAME_MAXLEN];
        char *description = NULL;
        int desc_ind;
        char vdir[TF_SERVICE_HOST_PATH_MAXLEN];
        int vdir_ind;
        char rsrcdir[TF_SERVICE_HOST_PATH_MAXLEN];
        int rsrcdir_ind;
        char connstr[TF_SERVICE_HOST_CONN_STR_MAXLEN];
        int status;
        int status_ind;
        char reason[TF_SERVICE_HOST_STATUS_REASON_MAXLEN];
        int reason_ind;
        int features;
        char resource[TF_CATALOG_RESOURCE_ID_MAXLEN];
        EXEC SQL END DECLARE SECTION;

        EXEC SQL AT :conn FETCH NEXT FROM fetch_hosts
            INTO :id, :parent:parent_ind, :name, :description:desc_ind, 
                 :vdir:vdir_ind, :rsrcdir:rsrcdir_ind, :connstr, 
                 :status:status_ind, :reason:reason_ind, :features, :resource;

        tf_host *item = (*result)[i] = (tf_host *)malloc(sizeof(tf_host));
        bzero(item, sizeof(tf_host));

        strncpy(item->id, id, TF_SERVICE_HOST_ID_MAXLEN);

        if (!parent_ind)
            strncpy(item->parent, parent, TF_SERVICE_HOST_ID_MAXLEN);

        strncpy(item->name, name, TF_SERVICE_HOST_NAME_MAXLEN);

        item->description = !desc_ind ? strdup(description) : NULL;

        if (!vdir_ind)
            strncpy(item->vdir, vdir, TF_SERVICE_HOST_PATH_MAXLEN);

        if (!rsrcdir_ind)
            strncpy(item->rsrcdir, rsrcdir, TF_SERVICE_HOST_PATH_MAXLEN);

        strncpy(item->connstr, connstr, TF_SERVICE_HOST_CONN_STR_MAXLEN);
        item->status = !status_ind ? status : 0;

        if (!reason_ind)
            strncpy(item->reason, reason, TF_SERVICE_HOST_STATUS_REASON_MAXLEN);

        item->features = features;
        strncpy(item->resource, resource, TF_CATALOG_RESOURCE_ID_MAXLEN);

        free(description);
    }

    EXEC SQL AT :conn CLOSE fetch_hosts;
    return TF_ERROR_SUCCESS;

error_cur:
    gcslog_error(sqlca.sqlerrm.sqlerrmc);

    EXEC SQL WHENEVER SQLERROR GOTO error;
    EXEC SQL AT :conn CLOSE fetch_hosts;

    return TF_ERROR_PG_FAILURE;

error:
    gcslog_error(sqlca.sqlerrm.sqlerrmc);
    return TF_ERROR_PG_FAILURE;
}

/**
 * Retrieves the given host from the database. Calling functions should
 * call tf_free_host() to free "result".
 *
 * @param ctx       current database context
 * @param id        host ID to match
 * @param result    pointer to an output buffer for the result
 *
 * @return TF_ERROR_SUCCESS or an error code
 */
tf_error tf_fetch_single_host(pgctx *ctx, const char *hostid, tf_host **result)
{
    if (!ctx || !hostid || !result || *result)
        return TF_ERROR_BAD_PARAMETER;

    gcslog_debug("looking up service host %s", hostid);

    EXEC SQL BEGIN DECLARE SECTION;
    const char *conn = ctx->conn;
    char selstmt[20480];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND GOTO not_found;
    EXEC SQL WHENEVER SQLERROR GOTO error;

    sprintf(selstmt, 
        "SELECT host_id, parent_host_id, \"name\", description, \
                virtual_directory, resource_directory, \
                connection_string, status, status_reason, \
                supported_features, fk_resource_identifier \
        FROM service_hosts \
        WHERE host_id = '%s'",
        hostid);
    gcslog_trace("fetch single service host SQL: %s", selstmt);

    EXEC SQL AT :conn PREPARE sqlstmt FROM :selstmt;

    EXEC SQL BEGIN DECLARE SECTION;
    char id[TF_SERVICE_HOST_ID_MAXLEN];
    char parent[TF_SERVICE_HOST_ID_MAXLEN];
    int parent_ind;
    char name[TF_SERVICE_HOST_NAME_MAXLEN];
    char *description = NULL;
    int desc_ind;
    char vdir[TF_SERVICE_HOST_PATH_MAXLEN];
    int vdir_ind;
    char rsrcdir[TF_SERVICE_HOST_PATH_MAXLEN];
    int rsrcdir_ind;
    char connstr[TF_SERVICE_HOST_CONN_STR_MAXLEN];
    int status;
    int status_ind;
    char reason[TF_SERVICE_HOST_STATUS_REASON_MAXLEN];
    int reason_ind;
    int features;
    char resource[TF_CATALOG_RESOURCE_ID_MAXLEN];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL AT :conn EXECUTE sqlstmt
        INTO :id, :parent:parent_ind, :name, :description:desc_ind, 
             :vdir:vdir_ind, :rsrcdir:rsrcdir_ind, :connstr, 
             :status:status_ind, :reason:reason_ind, :features, :resource;

    tf_host *item = *result = (tf_host *)malloc(sizeof(tf_host));
    bzero(item, sizeof(tf_host));

    strncpy(item->id, id, TF_SERVICE_HOST_ID_MAXLEN);

    if (!parent_ind)
        strncpy(item->parent, parent, TF_SERVICE_HOST_ID_MAXLEN);

    strncpy(item->name, name, TF_SERVICE_HOST_NAME_MAXLEN);

    item->description = !desc_ind ? strdup(description) : NULL;

    if (!vdir_ind)
        strncpy(item->vdir, vdir, TF_SERVICE_HOST_PATH_MAXLEN);

    if (!rsrcdir_ind)
        strncpy(item->rsrcdir, rsrcdir, TF_SERVICE_HOST_PATH_MAXLEN);

    strncpy(item->connstr, connstr, TF_SERVICE_HOST_CONN_STR_MAXLEN);
    item->status = !status_ind ? status : 0;

    if (!reason_ind)
        strncpy(item->reason, reason, TF_SERVICE_HOST_STATUS_REASON_MAXLEN);

    item->features = features;
    strncpy(item->resource, resource, TF_CATALOG_RESOURCE_ID_MAXLEN);

    free(description);

    return TF_ERROR_SUCCESS;

not_found:
    gcslog_debug("no matching service host found");
    return TF_ERROR_NOT_FOUND;

error:
    gcslog_error(sqlca.sqlerrm.sqlerrmc);
    return TF_ERROR_PG_FAILURE;
}

