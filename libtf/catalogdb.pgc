/**
 * GCS - open source group collaboration and application lifecycle management
 * Copyright (c) 2011 Bob Carroll
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/**
 * @brief	Team Foundation catalog database functions
 *
 * @author	Bob Carroll (bob.carroll@alum.rit.edu)
 */

#include <string.h>
#include <stdlib.h>

#include <gcs/pgctxpool.h>
#include <gcs/log.h>

#include <tf/catalogdb.h>
#include <tf/dbhelp.h>

/**
 * Retrieves catalog nodes from the database. Calling functions should
 * call tf_catalog_free_node_array() prior to freeing "result".
 *
 * @param pathspecs -- catalog paths without depth markers
 * @param types -- a null-terminated array of resource type ID strings to filter by
 * @param result -- pre-allocated output buffer for the results
 *
 * @returns TF_ERROR_SUCCESS or an error code
 */
tf_error_t tf_catalog_fetch_nodes(tf_catalog_pathspec_array_t pathspecs, const char * const *types,
	tf_catalog_node_array_t *result)
{
	if (pathspecs.count < 1 || result == NULL)
		return TF_ERROR_BAD_PARAMETER;

	gcslog_debug("looking up catalog nodes for %d path(s)", pathspecs.count);

	EXEC SQL BEGIN DECLARE SECTION;
	const char *conn = NULL;
	char countstmt[20480];
	char selstmt[20480];
	int count = 0;
	EXEC SQL END DECLARE SECTION;

	gcs_pgctx_t *ctx = gcs_pgctx_acquire();
	conn = ctx->conn;

	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL SET CONNECTION :conn;

	char where[10240];
	const int wherelen = 10240;
	int curpos = 0;
	int i = 0, r;
	tf_error_t dberr;

	bzero(&where, wherelen);

	for (i = 0; i < pathspecs.count; i++) {
		tf_catalog_pathspec_t *ps = &pathspecs.items[i];
		char *pathval = NULL;
		int oldpathlen = strlen(ps->path);
		int newpathlen = 0;

		if (i > 0) {
			r = snprintf(where + curpos, wherelen - curpos, " OR ");
			if (r >= wherelen - curpos) {
				gcs_pgctx_release(ctx);
				return TF_ERROR_PARAM_TOO_LONG;
			}

			curpos += 4;
		}

		if (ps->depth == TF_CATALOG_NODE_DEPTH_NONE) {
			pathval = (char *)alloca(sizeof(char) * (oldpathlen + 1));
			strcpy(pathval, ps->path);
		} else {
			pathval = (char *)alloca(sizeof(char) * (oldpathlen + 2));
			sprintf(pathval, "%s%%", ps->path);

			newpathlen = (ps->depth == TF_CATALOG_NODE_DEPTH_SINGLE) ?
				TF_CATALOG_CHILD_ITEM_MAXLEN - 1 :
				TF_CATALOG_PARENT_PATH_MAXLEN - 1;
		}

		r = snprintf(
			where + curpos, 
			wherelen - curpos, 
			"(cn.parent_path || cn.child_item LIKE '%s' AND char_length(cn.parent_path) <= %d)", 
			pathval,
			newpathlen);
		if (r >= wherelen - curpos) {
			gcs_pgctx_release(ctx);
			return TF_ERROR_PARAM_TOO_LONG;
		}

		curpos += strlen(where + curpos);
	}

	if (types[0] != NULL) {
		if (curpos >= wherelen - 28) {
			gcs_pgctx_release(ctx);
			return TF_ERROR_PARAM_TOO_LONG;
		}

		memmove(where + 1, where, curpos + 1);
		curpos++;

		where[0] = '(';
		sprintf(where + curpos, ") AND (crt.identifier IN (");
		curpos += 26;

		dberr = tf_db_build_list(types, where, wherelen, &curpos);
		if (dberr != TF_ERROR_SUCCESS) {
			gcs_pgctx_release(ctx);
			return dberr;
		}

		if (snprintf(where + curpos, wherelen - curpos, "))") >= wherelen - curpos) {
			gcs_pgctx_release(ctx);
			return TF_ERROR_PARAM_TOO_LONG;
		}

		curpos += strlen(where + curpos);
	}

	sprintf(countstmt, 
		"SELECT COUNT(*) \
		 FROM catalog_nodes AS cn \
		 INNER JOIN catalog_resources AS cr \
		    ON cn.resource_identifier = cr.identifier \
		 INNER JOIN catalog_resource_types AS crt \
		    ON cr.fk_resource_type = crt.identifier \
		 WHERE %s", 
		where);
	gcslog_trace("fetch catalog nodes SQL: %s", countstmt);

	EXEC SQL PREPARE fetchnodes_stmt FROM :countstmt;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL EXECUTE fetchnodes_stmt INTO :count;
	EXEC SQL DEALLOCATE PREPARE fetchnodes_stmt;

	gcslog_debug("found %d matching catalog node(s)", count);
	bzero(result, sizeof(tf_catalog_node_array_t));

	if (count == 0) {
		gcs_pgctx_release(ctx);
		return TF_ERROR_SUCCESS;
	}

	result->items = (tf_catalog_node_t *)calloc(count, sizeof(tf_catalog_node_t));
	result->count = count;

	sprintf(selstmt, 
		"SELECT cn.parent_path, cn.child_item, cn.\"default\", \
		       cr.identifier, cr.display_name, cr.description, \
		       crt.identifier, crt.display_name, crt.description \
		 FROM catalog_nodes AS cn \
		 INNER JOIN catalog_resources AS cr \
		    ON cn.resource_identifier = cr.identifier \
		 INNER JOIN catalog_resource_types AS crt \
		    ON cr.fk_resource_type = crt.identifier \
		 WHERE %s", 
		where);

	EXEC SQL PREPARE fetchnodes_stmt FROM :selstmt;

	EXEC SQL DECLARE cur1 CURSOR FOR fetchnodes_stmt;
	EXEC SQL OPEN cur1;

	for (i = 0; ; i++) {
		EXEC SQL WHENEVER NOT FOUND DO BREAK;

		EXEC SQL BEGIN DECLARE SECTION;
		char parent[TF_CATALOG_PARENT_PATH_MAXLEN];
		char child[TF_CATALOG_CHILD_ITEM_MAXLEN];
		int fdefault;
		char resid[TF_CATALOG_RESOURCE_ID_MAXLEN];
		char resname[TF_CATALOG_RESOURCE_NAME_MAXLEN];
		char *resdesc = NULL;
		int resdesc_ind;
		char typeid[TF_CATALOG_RESOURCE_TYPE_MAXLEN];
		char typename[TF_CATALOG_RESOURCE_TYPE_NAME_MAXLEN];
		char *typedesc = NULL;
		int typedesc_ind;
		EXEC SQL END DECLARE SECTION;

		EXEC SQL FETCH NEXT FROM cur1
			INTO :parent, :child, :fdefault,
			     :resid, :resname, :resdesc:resdesc_ind,
			     :typeid, :typename, :typedesc:typedesc_ind;

		strncpy(result->items[i].parent, parent, TF_CATALOG_PARENT_PATH_MAXLEN);
		strncpy(result->items[i].child, child, TF_CATALOG_CHILD_ITEM_MAXLEN);
		result->items[i].fdefault = fdefault;

		strncpy(result->items[i].resource.id, resid, TF_CATALOG_RESOURCE_NAME_MAXLEN);
		strncpy(result->items[i].resource.name, resname, TF_CATALOG_RESOURCE_NAME_MAXLEN);
		result->items[i].resource.description = !resdesc_ind ? strdup(resdesc) : NULL;

		strncpy(result->items[i].resource.type.id, typeid, TF_CATALOG_RESOURCE_TYPE_MAXLEN);
		strncpy(result->items[i].resource.type.name, typename, TF_CATALOG_RESOURCE_TYPE_NAME_MAXLEN);
		result->items[i].resource.type.description = !typedesc_ind ? strdup(typedesc) : NULL;

		free(resdesc);
		free(typedesc);
	}

	EXEC SQL CLOSE cur1;
	EXEC SQL DEALLOCATE PREPARE fetchnodes_stmt;
	gcs_pgctx_release(ctx);

	return TF_ERROR_SUCCESS;

error:
	gcs_pgctx_release(ctx);
	gcslog_error(sqlca.sqlerrm.sqlerrmc);
	return TF_ERROR_PG_FAILURE;
}

/**
 * Retrieves catalog nodes from the database by resource ID. Calling functions
 * should call tf_catalog_free_node_array() prior to freeing "result".
 *
 * @param idarr -- a null-terminated array of resource ID strings to lookup
 * @param types -- flag to indicate if idarr has resource type ID strings
 * @param result -- pre-allocated output buffer for the results
 *
 * @returns TF_ERROR_SUCCESS or an error code
 */
tf_error_t tf_catalog_fetch_resources(const char * const *idarr, int types, tf_catalog_node_array_t *result)
{
	if (idarr == NULL || idarr[0] == NULL || result == NULL)
		return TF_ERROR_BAD_PARAMETER;

	gcslog_debug("looking up catalog resources");

	EXEC SQL BEGIN DECLARE SECTION;
	const char *conn = NULL;
	char countstmt[20480];
	char selstmt[20480];
	int count = 0;
	EXEC SQL END DECLARE SECTION;

	gcs_pgctx_t *ctx = gcs_pgctx_acquire();
	conn = ctx->conn;

	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL SET CONNECTION :conn;

	char residlst[10240];
	const int residlen = 10240;
	int curpos = 0;
	tf_error_t dberr;

	bzero(&residlst, residlen);

	dberr = tf_db_build_list(idarr, residlst, residlen, &curpos);
	if (dberr != TF_ERROR_SUCCESS) {
		gcs_pgctx_release(ctx);
		return dberr;
	}

	sprintf(countstmt, 
		"SELECT COUNT(*) \
		 FROM catalog_nodes AS cn \
		 INNER JOIN catalog_resources AS cr \
		    ON cn.resource_identifier = cr.identifier \
		 INNER JOIN catalog_resource_types AS crt \
		    ON cr.fk_resource_type = crt.identifier \
		 WHERE %s IN (%s)", 
		types ? "crt.identifier" : "cr.identifier", 
		residlst);
	gcslog_trace("fetch catalog resources SQL: %s", countstmt);

	EXEC SQL PREPARE fetchres_stmt FROM :countstmt;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL EXECUTE fetchres_stmt INTO :count;
	EXEC SQL DEALLOCATE PREPARE fetchres_stmt;

	gcslog_debug("found %d matching resource(s)", count);
	bzero(result, sizeof(tf_catalog_node_array_t));

	if (count == 0) {
		gcs_pgctx_release(ctx);
		return TF_ERROR_SUCCESS;
	}

	result->items = (tf_catalog_node_t *)calloc(count, sizeof(tf_catalog_node_t));
	result->count = count;

	sprintf(selstmt, 
		"SELECT cn.parent_path, cn.child_item, cn.\"default\", \
		       cr.identifier, cr.display_name, cr.description, \
		       crt.identifier, crt.display_name, crt.description \
		 FROM catalog_nodes AS cn \
		 INNER JOIN catalog_resources AS cr \
		    ON cn.resource_identifier = cr.identifier \
		 INNER JOIN catalog_resource_types AS crt \
		    ON cr.fk_resource_type = crt.identifier \
		 WHERE %s IN (%s)", 
		types ? "crt.identifier" : "cr.identifier", 
		residlst);

	EXEC SQL PREPARE fetchres_stmt FROM :selstmt;

	EXEC SQL DECLARE cur2 CURSOR FOR fetchres_stmt;
	EXEC SQL OPEN cur2;

	int i;
	for (i = 0; ; i++) {
		EXEC SQL WHENEVER NOT FOUND DO BREAK;

		EXEC SQL BEGIN DECLARE SECTION;
		char parent[TF_CATALOG_PARENT_PATH_MAXLEN];
		char child[TF_CATALOG_CHILD_ITEM_MAXLEN];
		int fdefault;
		char resid[TF_CATALOG_RESOURCE_ID_MAXLEN];
		char resname[TF_CATALOG_RESOURCE_NAME_MAXLEN];
		char *resdesc = NULL;
		int resdesc_ind;
		char typeid[TF_CATALOG_RESOURCE_TYPE_MAXLEN];
		char typename[TF_CATALOG_RESOURCE_TYPE_NAME_MAXLEN];
		char *typedesc = NULL;
		int typedesc_ind;
		EXEC SQL END DECLARE SECTION;

		EXEC SQL FETCH NEXT FROM cur2
			INTO :parent, :child, :fdefault,
			     :resid, :resname, :resdesc:resdesc_ind,
			     :typeid, :typename, :typedesc:typedesc_ind;

		strncpy(result->items[i].parent, parent, TF_CATALOG_PARENT_PATH_MAXLEN);
		strncpy(result->items[i].child, child, TF_CATALOG_CHILD_ITEM_MAXLEN);
		result->items[i].fdefault = fdefault;

		strncpy(result->items[i].resource.id, resid, TF_CATALOG_RESOURCE_NAME_MAXLEN);
		strncpy(result->items[i].resource.name, resname, TF_CATALOG_RESOURCE_NAME_MAXLEN);
		result->items[i].resource.description = !resdesc_ind ? strdup(resdesc) : NULL;

		strncpy(result->items[i].resource.type.id, typeid, TF_CATALOG_RESOURCE_TYPE_MAXLEN);
		strncpy(result->items[i].resource.type.name, typename, TF_CATALOG_RESOURCE_TYPE_NAME_MAXLEN);
		result->items[i].resource.type.description = !typedesc_ind ? strdup(typedesc) : NULL;

		free(resdesc);
		free(typedesc);
	}

	EXEC SQL CLOSE cur2;
	EXEC SQL DEALLOCATE PREPARE fetchres_stmt;
	gcs_pgctx_release(ctx);

	return TF_ERROR_SUCCESS;

error:
	gcs_pgctx_release(ctx);
	gcslog_error(sqlca.sqlerrm.sqlerrmc);
	return TF_ERROR_PG_FAILURE;
}

/**
 * Retrieves catalog service references from the database. Calling functions
 * should call tf_catalog_free_service_array() prior to freeing "result".
 *
 * @param nodes -- an array of nodes to lookup services for
 * @param result -- pre-allocated output buffer for the results
 *
 * @returns TF_ERROR_SUCCESS or an error code
 */
tf_error_t tf_catalog_fetch_services(tf_catalog_node_array_t nodes, tf_catalog_service_array_t *result)
{
	if (nodes.count < 1 || result == NULL)
		return TF_ERROR_BAD_PARAMETER;

	gcslog_debug("looking up catalog services for %d node(s)", nodes.count);

	EXEC SQL BEGIN DECLARE SECTION;
	const char *conn = NULL;
	char countstmt[20480];
	char selstmt[20480];
	int count = 0;
	EXEC SQL END DECLARE SECTION;

	gcs_pgctx_t *ctx = gcs_pgctx_acquire();
	conn = ctx->conn;

	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL SET CONNECTION :conn;

	char residlst[10240];
	const int residlen = 10240;
	int curpos = 0;
	int r = residlen - curpos, i = 0;

	bzero(&residlst, residlen);

	for (i = 0; i < nodes.count; i++) {
		if (i > 0) {
			if (snprintf(residlst + curpos, r, ", ") >= r) {
				gcs_pgctx_release(ctx);
				return TF_ERROR_PARAM_TOO_LONG;
			}

			curpos += 2;
			r = residlen - curpos;
		}

		if (snprintf(residlst + curpos, r, "'%s'", nodes.items[i].resource.id) >= r) {
			gcs_pgctx_release(ctx);
			return TF_ERROR_PARAM_TOO_LONG;
		}

		curpos += strlen(residlst + curpos);
		r = residlen - curpos;
	}

	sprintf(countstmt, 
		"SELECT COUNT(*) \
		FROM catalog_service_references AS csr \
		JOIN service_definitions AS sd \
		   ON csr.fk_service_identifier = sd.identifier \
		   AND csr.fk_service_type = sd.service_type \
		JOIN tool_types AS tt \
		   ON sd.fk_tool_id = tt.id \
		WHERE csr.resource_identifier IN (%s)", 
		residlst);
	gcslog_trace("fetch catalog services SQL: %s", countstmt);

	EXEC SQL PREPARE sref_stmt FROM :countstmt;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL EXECUTE sref_stmt INTO :count;
	EXEC SQL DEALLOCATE PREPARE sref_stmt;

	gcslog_debug("found %d catalog service(s)", count);
	bzero(result, sizeof(tf_catalog_service_array_t));

	if (count == 0) {
		gcs_pgctx_release(ctx);
		return TF_ERROR_SUCCESS;
	}

	result->items = (tf_catalog_service_t *)calloc(count, sizeof(tf_catalog_service_t));
	result->count = count;

	sprintf(selstmt, 
		"SELECT csr.resource_identifier, csr.association_key, \
		        sd.identifier, sd.service_type, sd.display_name, \
		        sd.relative_to_setting, sd.relative_path, \
		        sd.singleton, sd.description, tt.type \
		FROM catalog_service_references AS csr \
		JOIN service_definitions AS sd \
		   ON csr.fk_service_identifier = sd.identifier \
		   AND csr.fk_service_type = sd.service_type \
		JOIN tool_types AS tt \
		   ON sd.fk_tool_id = tt.id \
		WHERE csr.resource_identifier IN (%s)", 
		residlst);

	EXEC SQL PREPARE sref_stmt FROM :selstmt;

	EXEC SQL DECLARE cur3 CURSOR FOR sref_stmt;
	EXEC SQL OPEN cur3;

	for (i = 0; ; i++) {
		EXEC SQL WHENEVER NOT FOUND DO BREAK;

		EXEC SQL BEGIN DECLARE SECTION;
		char resid[TF_CATALOG_RESOURCE_ID_MAXLEN];
		char assockey[TF_CATALOG_ASSOCIATION_KEY_MAXLEN];
		char svcid[TF_LOCATION_SERVICE_ID_MAXLEN];
		char svctype[TF_LOCATION_SERVICE_TYPE_MAXLEN];
		char svcname[TF_LOCATION_SERVICE_NAME_MAXLEN];
		int reltosetting;
		char relpath[TF_LOCATION_SERVICE_REL_PATH_MAXLEN];
		int relpath_ind;
		int singleton;
		char *svcdesc = NULL;
		int svcdesc_ind;
		char tooltype[TF_LOCATION_SERVICE_TOOL_TYPE_MAXLEN];
		EXEC SQL END DECLARE SECTION;

		EXEC SQL FETCH NEXT FROM cur3
			INTO :resid, :assockey, :svcid, :svctype, :svcname, :reltosetting,
			     :relpath:relpath_ind, :singleton, :svcdesc:svcdesc_ind, :tooltype;

		strncpy(result->items[i].id, resid, TF_CATALOG_RESOURCE_NAME_MAXLEN);
		strncpy(result->items[i].assockey, assockey, TF_CATALOG_ASSOCIATION_KEY_MAXLEN);

		strncpy(result->items[i].service.id, svcid, TF_LOCATION_SERVICE_ID_MAXLEN);
		strncpy(result->items[i].service.type, svctype, TF_LOCATION_SERVICE_TYPE_MAXLEN);
		strncpy(result->items[i].service.name, svcname, TF_LOCATION_SERVICE_NAME_MAXLEN);
		strncpy(result->items[i].service.tooltype, tooltype, TF_LOCATION_SERVICE_TOOL_TYPE_MAXLEN);

		result->items[i].service.reltosetting = reltosetting;
		result->items[i].service.singleton = singleton;

		if (!relpath_ind)
			strncpy(result->items[i].service.relpath, relpath, TF_LOCATION_SERVICE_REL_PATH_MAXLEN);

		result->items[i].service.description = !svcdesc_ind ? strdup(svcdesc) : NULL;

		free(svcdesc);
	}

	EXEC SQL CLOSE cur3;
	EXEC SQL DEALLOCATE PREPARE sref_stmt;
	gcs_pgctx_release(ctx);

	return TF_ERROR_SUCCESS;

error:
	gcs_pgctx_release(ctx);
	gcslog_error(sqlca.sqlerrm.sqlerrmc);
	return TF_ERROR_PG_FAILURE;
}

